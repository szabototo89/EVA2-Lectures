<!DOCTYPE html>
<html>
<head>
  <title>Eseményvezérelt alkalmazások fejlesztése 2 - Szabó Tamás &#169;</title>
  <script src="js/jquery.min.js"></script>
  <script src="js/shCore.js"></script>
  <script src="js/shBrushCSharp.js"></script>
  <script src="js/shBrushXml.js"></script>
  <script src="js/lecture.js"></script>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:300' rel='stylesheet' type='text/css'>
  <link href="css/shCore.css" rel="stylesheet" type="text/css"/>
  <link href="css/shCoreDefault.css" rel="stylesheet" type="text/css"/>
  <link href="css/slides-800x600.css" rel="stylesheet" type="text/css" />

  <script type="slide-template" id="main">
    <div class="step slide main" data-x="$index*1500$">
      $content$
    </div>
  </script>

  <script type="slide-template" id="standard">
    <div class="step slide" data-x="$index*1500$">
      <div class="title">
        <div>$title$</div>
      </div>
      <div class="subtitle">
        <div>8 - WPF alapjai</div>
      </div>
      <div class="content">$content$</div>
    </div>
  </script>

</head>
<!-- ou -->
<body>
  <div id="impress">
    <div class="slide" data-template="main">
      <div class="centered">
        <h1>Eseményvezérelt alkalmazások fejlesztése 2.</h1>
        <h2>8. gyakorlat - Windows Presentation Foundation alapjai 2.</h2>
      </div>
    </div>

    <div class="slide" data-title="Offtopic: Reactive Programming">
      <ul>
        <li>Nemrégen indult a <a href="http://www.coursera.org">Coursera</a>-n két online (ingyenes) kurzus:
          <ul>
            <li><a href="https://www.coursera.org/course/reactive">Principles of Reactive Programming</a></li>
            <li><a href="https://www.coursera.org/course/progfun">Functional Programming Principles in Scala by Martin Odersky</a></li>
          </ul>
        </li>
        <li>Aki szeretne megismerkedni a <strong>Scala</strong> nyelv alapjaival (illetve a funkcionális programozás alapelveit is szeretné újra átismételni), annak a második eloadás sorozatot ajánlom.</li>
        <li>A <strong>Reactive Programming</strong> az aszinkronos programozást tudja nekünk nagyon leegyszerusíteni, úgy, hogy maga a kódolvashatóság is megmarad. </li>
        <li>A <strong>Reactive Programming</strong> pedig egy .NET-es technológiával is kapcsolatban van: ez lenne az Rx (Reactive Extensions). Rengeteg mindenre használható, GUI készítések tekintetében az eseményekre való reagálást lehet nagyon egyszeruen kezelni vele. Akit jobban érdekel a téma, az nézze meg az elso eloadás sorozatot, illetve elérheto az <strong>Rx</strong>-hez egy <a href="https://devportal.hu/Fajlok/Details.aspx?shareid=1&path=Konyvek%5CWindows+8+l%C3%A9p%C3%A9sr%C5%91l+l%C3%A9p%C3%A9sre%5CRx+-+Aszinkron+programoz%C3%A1s+magas+fokon.pdf">magyar nyelvu jegyzet</a> a <strong>devportal</strong>-ról.</li>
      </ul>
    </div>

    <div class="slide" data-title="Rétegek a WPF-ben">
      <ul>
        <li>A <strong>WPF</strong>-ben a vezérloket csak szüloelemekbe tudjuk helyezni. Ezek lehetnek olyan vezérlok, amik egy gyerekvezérlo megjelenítésére szolgálnak (<a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.contentcontrol.aspx">ContentControl</a>), esetleg egyszerre többre (<a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a>), illetve rétegekbe (<a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.panel.aspx">Panel</a>) is helyezhetjük oket, amiknek segítségével valamilyen alakzatba rendezi azokat. A következo diákon ezekrol a rétegekrol (panelekrol) lesz szó.</li>
        <li>De honnan is tudja a <strong>WPF</strong>, hogy hogyan kell elhelyezni a vezérloket egy adott elemen belül? Hiszen ahhoz, hogy minden pontosan illeszkedjen pár információra mindenképpen szüksége van. Eloször is tudnia kell, hogy az adott vezérlonek pontosan mennyi helyre is lesz szüksége (<a href="http://msdn.microsoft.com/en-us/library/system.windows.uielement.measure.aspx">measure</a>). Ha ezek az információk összegyultek, akkor jön a tényleges elhelyezése a vezérloknek (<a href="http://msdn.microsoft.com/en-us/library/system.windows.uielement.arrange.aspx">arrange</a>), ahol már pontosan tudjuk, hogy mennyi hely áll rendelkezésre és ennek alapján kell kirajzolni az adott vezérlot.</li>
        <li>Az elobbi technikával akár már mi is egyszeruen készíthetünk saját készítésu rétegeket, egyszeruen csak úgy, hogy leszármaztatunk a <a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.panel.aspx">Panel</a> osztályból, vagy a már meglévokbol. </li>
      </ul>
    </div>

    <div class="slide" data-title="Rétegek a WPF-ben (Canvas)">
      <ul>
        <li><a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.canvas.aspx">Canvas</a>: Talán az egyik legegyszerubb panel, hiszen a felhasználó <a href="#" class="tooltip" data-tooltip="nem igazán pixel (sokkal inkább dpi), hiszen sok minden más is közrejátszik">pixel</a> pontosan adhatja meg, hogy éppen hol helyezkedjen el az adott vezérlo. Nem igazán szeretjük, hiszen valójában abszolút pozicionálás történik, ami teljesen ellentmond a <strong>WPF</strong> alapelveinek, ezért ha lehet csak nagyon speciális helyzetekben használjuk. A pozicionálásokat a <strong>Canvas.Left</strong> és <strong>Canvas.Top</strong> tulajdonságokon keresztül tehetjük meg: </li>
        <img src="img/canvas.png" style="margin-left: 27%">
        <pre class="brush:xml">
          &lt;Canvas&gt;
            &lt;Rectangle Canvas.Left="40" Canvas.Top="31" Width="63" Height="41" Fill="Blue"  /&gt;
            &lt;Ellipse Canvas.Left="130" Canvas.Top="79" Width="58" Height="58" Fill="Blue"  /&gt;
            &lt;Path Canvas.Left="61" Canvas.Top="28" Width="133" Height="98" Fill="Blue" 
                  Stretch="Fill" Data="M61,125 L193,28"/&gt;
          &lt;/Canvas&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="Rétegek a WPF-ben (StackPanel)">
      <ul>
        <li><a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.stackpanel.aspx">StackPanel</a>: Egy másik nagyon egyszeru réteg, ami a gyerekelemeit egymásután veremszeruen helyezi el. Felsorolásokra nagyon jól használhat. Fontos megjegyezni, hogy az utolsó gyerek nem fogja kihasználni a rendelkezésére álló helyet. Az <a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.stackpanel.orientation.aspx">Orientation</a> tulajdonságon keresztül kétféleképpen helyezhetjük el a gyerekeket a panelben: vízszintesen (<strong>Horizontal</strong>), illetve függolegesen (<strong>Vertical</strong>). </li>
        <a href="img/stackpanel.jpg" class="image-link"><img src="img/stackpanel.jpg" style="margin-left: 35%; width: 25%"></a>
        <pre class="brush:xml">
          &lt;StackPanel&gt;
            &lt;TextBlock Margin="10" FontSize="20"&gt;How do you like your coffee?&lt;/TextBlock&gt;
            &lt;Button Margin="10"&gt;Black&lt;/Button&gt;
            &lt;Button Margin="10"&gt;With milk&lt;/Button&gt;
            &lt;Button Margin="10"&gt;Latte machiato&lt;/Button&gt;
            &lt;Button Margin="10"&gt;Chappuchino&lt;/Button&gt;
          &lt;/StackPanel&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="Rétegek a WPF-ben (DockPanel)">
      <ul>
        <li><a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.dockpanel.aspx">DockPanel</a>: A <strong>DockPanel</strong> nevéhez hasonlóan dokkszeruen rendezi el az elemeket attól függoen, hogy a vezérlo <strong>DockPanel.Dock</strong> tulajdonságának mit állítottunk be. Ennek megfeleloen négy különbözo irányba csoportosíthatjuk a gyerekelemeket: balra (<strong>Left</strong>), jobbra (<strong>Right</strong>), felülre (<strong>Top</strong>), illetve alulra (<strong>Bottom</strong>). Lehetoségünk beállítani a <strong>LastChildFill</strong> tulajdonságon keresztül azt is, hogy a legutolsó gyerek kitöltse a számára elérheto legnagyobb helyet. </li>
        <a href="img/dockpanel.png" class="image-link"><img src="img/dockpanel.png" style="margin-left: 35%; width: 35%"></a>
        <pre class="brush:xml">
          &lt;DockPanel LastChildFill="True"&gt;
              &lt;Button Content="Dock=Top" DockPanel.Dock="Top"/&gt;
              &lt;Button Content="Dock=Bottom" DockPanel.Dock="Bottom"/&gt;
              &lt;Button Content="Dock=Left"/&gt;
              &lt;Button Content="Dock=Right" DockPanel.Dock="Right"/&gt;
              &lt;Button Content="LastChildFill=True"/&gt;
          &lt;/DockPanel&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="Rétegek a WPF-ben (Grid) (1/2)">
      <ul>
        <li><a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.grid.aspx">Grid</a>: A <strong>Grid</strong> az egyik leggyakrabban használt panel a <strong>WPF</strong>-ben. Rendkívül széleskörben lehet alkalmazni és nagyon sok esetben szolgálhat segítségül. Használata nagyon egyszeru, a <strong>ColumnDefinitions</strong> és <strong>RowDefinitions</strong>-on keresztül állíthatjuk be, hogy hány sora és oszlopa legyen és mekkorák legyenek azok (itt meg lehet adni abszolút méreteket is, de a <strong>*</strong> literállal arányokat defininálhatunk közöttük). Ezzel még nem vagyunk készen, mert a gyerekelemeknél is be kell állítanunk a <strong>Grid.Row</strong> és <strong>Grid.Column</strong>-on keresztül, hogy hol helyezkedjenek el azok, míg a <strong>Grid.RowSpan</strong> és <strong>Grid.ColumnSpan</strong>-al azt állíthatjuk be, hogy hány soron és oszlopon keresztül "nyúljanak" át. </li>
        <li>A <strong>ShowGridLines</strong> tulajdonság értékének igazra állításával vizuálissá tehetjük az oszlopok és sorok közötti elhelyezkedést, de ezt csak tervezéskor használjuk, kész kódnál sose!</li>
      </ul>
    </div>

    <div class="slide" data-title="Rétegek a WPF-ben (Grid) (2/2)">
      <a href="img/grid.png" class="image-link"><img src="img/grid.png" style="margin-left: 25%; width: 45%"></a>
      <pre class="brush:xml">
        &lt;Grid ShowGridLines="True"&gt;
          &lt;Grid.RowDefinitions&gt;
            &lt;RowDefinition Height="Auto" /&gt;
            &lt;RowDefinition Height="Auto" /&gt;
            &lt;RowDefinition Height="*" /&gt;
          &lt;/Grid.RowDefinitions&gt;
          &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width="Auto" /&gt;
            &lt;ColumnDefinition Width="200" /&gt;
          &lt;/Grid.ColumnDefinitions&gt;
          &lt;Label Grid.Row="0" Grid.Column="0" Content="Name:" /&gt;
          &lt;Label Grid.Row="1" Grid.Column="0" Content="E-Mail:" /&gt;
          &lt;Label Grid.Row="2" Grid.Column="0" Content="Comment:" /&gt;
          &lt;TextBox Grid.Column="1" Grid.Row="0" Margin="3" /&gt;
          &lt;TextBox Grid.Column="1" Grid.Row="1" Margin="3" /&gt;
          &lt;TextBox Grid.Column="1" Grid.Row="2" Margin="3" /&gt;
        &lt;/Grid&gt;
      </pre>
    </div>

    <div class="slide" data-title="Trigger-ek használata (1/2)">
      <ul>
        <li>Vannak olyan esetek, amikor a vezérlonek valamilyen felhasználói interakcióra, esetleg valamilyen érték megváltozására reagálnia kell. Ilyen ez a reagálás lehet üzleti logika szintu, vagy csak valamilyen design-beli változás. A <strong>trigger</strong>-ek az utóbbira adnak egy nagyon hasznos megoldást, amivel egyszeruen és elegánsan tudunk reagálni az állapotváltozásokra.</li>
        <li>A <strong>trigger</strong>-ek használatának elve nagyon egyszeru. Ha megváltozik egy adott állapot értéke, akkor maga a kapcsoló, a neki átadott változásokat fogja végrehajtani az adott vezérlon. Üzleti logika alkalmazására nem igazán való (de persze ezzel is lehet trükközni). </li>
        <li>Minden vezérlonek meg lehet határozni különbözo <strong>trigger</strong>-eket, viszont ezekben az esetekben meg van kötve a kezünk, ugyanis csak <a href="http://msdn.microsoft.com/en-us/library/system.windows.eventtrigger.aspx">EventTrigger</a>-eket lehet definiálni (ezek olyan kapcsolók, amik egy adott eseményre figyelnek, és ha kiváltódik, akkor aktíválódik maga a kapcsoló is). Stílusoknak és sablonoknak viszont bármilyen típusú kapcsolót meg lehet adni. Gyakran használt trükk szokott lenni ezért, hogy a stíluson keresztül adjuk meg a vezérlonek a <strong>trigger</strong>-t.</li>
      </ul>
    </div>

    <div class="slide" data-title="Trigger-ek használata (2/2)">
      <ul>
        <pre class="brush:xml">
          &lt;Button Content="Ok"&gt;
            &lt;!-- Sokszor bevett trükk, hogy stíluson keresztül adunk meg kapcsolót --&gt;
            &lt;Button.Style&gt;
              &lt;Style TargetType="Button"&gt;
                &lt;Style.Triggers&gt;
                  &lt;!-- Figyeljük az IsMouseOver tulajdonságot, ami ha igazra vált
                  (azaz, ha a felhasználó ráment az egérrel a vezérlonkre), akkor
                  aktiválódjon a kapcsolónk
                  --&gt;
                  &lt;Trigger Property="IsMouseOver" Value="True"&gt;
                    &lt;!-- 
                      Ha aktiválódott, akkor megváltoztatjuk a Content tulajdonságunk értékét.
                      Több Setter-t is definiálhatunk, ha azt szeretnénk.
                    --&gt;
                    &lt;Setter Property="Content" Value="Click on me!" /&gt;
                  &lt;/Trigger&gt;
                &lt;/Style.Triggers&gt;
              &lt;/Style&gt;
            &lt;/Button.Style&gt;
          &lt;/Button&gt;
        </pre>
        <li>Ha nem az adott vezérlonk tulajdonságát, akarjuk figyelni, akkor megtehetjük, hogy adatkötéssel akaszkadunk rá egy másik tulajdonság értékére. Erre a <a href="http://msdn.microsoft.com/en-us/library/system.windows.datatrigger.aspx">DataTrigger</a> típusú kapcsoló való. A <strong>Property</strong> tulajdonság helyett, a <strong>Binding</strong>-ot kell használni. </li>
        <li>Ha több feltételünk lenne, akkor a <strong>Multi-</strong> prefixxel kezdodo kapcsolókat kell használnunk: <a href="http://msdn.microsoft.com/en-us/library/system.windows.multitrigger.aspx">MultiTrigger</a>, <a href="http://msdn.microsoft.com/en-us/library/system.windows.multidatatrigger.aspx">MultiDataTrigger</a>. </li>
      </ul>
    </div>

    <div class="slide" data-title="Stílusok">
      <ul>
        <li>A <strong>WPF</strong> lehetoséget nyújt a felhasználónak arra, hogy a különbözo vezérloknek stílusokat definiálhasson. Ezzel a módszerrel az ugyanolyan típusú vezérloknek közös tulajdonságokat állíthatunk be egységesen anélkül, hogy azokat külön-külön nekünk kellene beállítani. Így a kódbázisunkat sokkal könnyebben lehet karbantartani, nem beszélve arról, hogy kevesebb kódot kell felügyelnünk. </li>
        <li>A stílusokkal szinte bármit be tudunk állítani: <a href="#" class="tooltip" data-tooltip="trigger">kapcsolókat</a>, <a href="#" class="tooltip" data-tooltip="setter-eken keresztül">tulajdonságokat</a>, eseményeket, így kelloen nagy szabadságot élvezünk a használatuknál.</li>
        <pre class="brush:xml">
        &lt;Style TargetType="Button"&gt;
          &lt;Setter Property="Cursor" Value="Hand" /&gt;
          &lt;Setter Property="Foreground" Value="Blue" /&gt;
          &lt;Setter Property="Template"&gt;
            &lt;Setter.Value&gt;
              &lt;ControlTemplate TargetType="Button"&gt;
                &lt;ControlTemplate.Resources&gt;
                  &lt;Style TargetType="TextBlock"&gt;
                    &lt;Setter Property="VerticalAlignment" Value="Center" /&gt;
                    &lt;Setter Property="HorizontalAlignment" Value="Center" /&gt;
                    &lt;Setter Property="TextDecorations" Value="Underline" /&gt;
                  &lt;/Style&gt;
                &lt;/ControlTemplate.Resources&gt;
              &lt;TextBlock Text="{TemplateBinding Content}" Foreground="{TemplateBinding Foreground}"/&gt;
              &lt;/ControlTemplate&gt;
            &lt;/Setter.Value&gt;
          &lt;/Setter&gt;
        &lt;/Style&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="Stílusok használata">
      <ul>
        <li>Stílusokat a <a href="http://msdn.microsoft.com/en-us/library/system.windows.style.aspx">Style</a> osztály példányosítával lehet definiálni. A stílusoknak meg kell adni a <a href="http://msdn.microsoft.com/en-us/library/system.windows.style.targettype.aspx">TargetType</a> tulajdonságon keresztül, hogy milyen típusú vezérlokre szeretnénk alkalmazni azt. </li>
        <li>Minden <a href="#" class="tooltip" data-tooltip="FrameworkElement osztály definiálja">vezérlonek</a> van egy <a href="http://msdn.microsoft.com/en-us/library/system.windows.frameworkelement.style.aspx">Style</a> nevu tulajdonsága, aminek ha értéket adunk, akkor a rendszer figyelembe veszi a stílusoknál megadott értékeket is.</li>
        <li>Másik lehetoség, hogy nem explicite adjuk meg a stílusokat, hanem valamelyik szüloelem <strong>Resources</strong> eroforrásai között példányosítjuk. Ezenbelül is két lehetoségünk van: ha nem adunk meg kulcsot az stílusnak (mint eroforrásnak), akkor minden azonos típusú vezérlore automatikusan érvényes lesz az adott stílus a fa gyermekei között (kivéve ha explicite nem állítottunk be neki egy másik stílust). Ha viszont megadunk, akkor csak a <strong>StaticResource/DynamicResource</strong> segítségével tudjuk elérni explicite. </li>
        <li>Hogy minél kevesebb legyen a kód duplikáció, ezért lehetoség van arra, hogy a már meglévo stílusból örököltessünk tulajdonságokat, majd a meglévoket megváltoztassuk, illetve új tulajdonságértékeket állítsunk be. Ezt a <a href="http://msdn.microsoft.com/en-us/library/system.windows.style.basedon.aspx">BasedOn</a> tulajdonságon keresztül tudjuk megtenni.</li>
      </ul>
    </div>

    <div class="slide" data-title="Setter/EventSetter osztály (1/2)">
      <ul>
        <li>A tulajdonságokat és eseményeket különbözo <a href="http://msdn.microsoft.com/en-us/library/system.windows.setterbase.aspx">SetterBase</a> osztály leszármazottjaival lehet megadni a <a href="http://msdn.microsoft.com/en-us/library/system.windows.style.setters.aspx">Style.Setters</a> tulajdonságon keresztül.</li>
        <pre class="brush:xml">
          &lt;Style TargetType="TextBlock"&gt;
            &lt;Style.Setters&gt; 
              &lt;Setter Property="Background" Value="Red" /&gt;
            &lt;/Style.Setters&gt;
          &lt;/Style&gt;
        </pre>
        <li>A könnyebb használhatóság miatt, a <strong>Setters</strong> tag-eket el lehet hagyni:</li>
        <pre class="brush:xml">
          &lt;Style TargetType="TextBlock"&gt;
            &lt;Setter Property="Background" Value="Red" /&gt;
          &lt;/Style&gt;
        </pre>
        <li>A tulajdonságokat a <a href="http://msdn.microsoft.com/en-us/library/system.windows.setter.aspx">Setter</a> objektummokkal lehet beállítani. A <a href="http://msdn.microsoft.com/en-us/library/system.windows.setter.property.aspx">Property</a>-n keresztül kell megadni, hogy vezérlo mely tulajdonságát szeretnénk beállítani, míg a <a href="http://msdn.microsoft.com/en-us/library/system.windows.setter.value(v=vs.110).aspx">Value</a>-n keresztül tudjuk megadni a pontos értékét. Ha egy elnevezett vezérlonek kell pontosan megadni az értéket, akkor a <a href="http://msdn.microsoft.com/en-us/library/system.windows.setter.targetname(v=vs.110).aspx">TargetName</a> tulajdonságnak kell értéket adni. Ez viszont csak a <strong>trigger</strong>-eknél használható, stílusoknál nem.</li>
        <li>Az <a href="http://msdn.microsoft.com/en-us/library/system.windows.eventsetter.aspx">EventSetter</a>-eken keresztül pedig az adott eseményekre iratkozhatunk fel. </li>
      </ul>
    </div>

    <div class="slide" data-title="Setter/EventSetter osztály (2/2)">
      <ul>
        <li>Lássunk néhány példát a használatukhoz (<strong>MainWindow.xaml</strong>):</li>
        <pre class="brush:xml">
          &lt;Style TargetType="TextBlock" x:Key="TextBlockStyle"&gt;
            &lt;Style.Setters&gt;
              &lt;EventSetter Event="MouseDown" Handler="TextBlockMouseDown" /&gt;
              &lt;Setter Property="Foreground" Value="White" /&gt;
              &lt;Setter Property="Background"&gt;
                &lt;Setter.Value&gt;
                  &lt;SolidColorBrush Color="Blue" Opacity="0.5" /&gt;
                &lt;/Setter.Value&gt;
              &lt;/Setter&gt;
            &lt;/Style.Setters&gt;
          &lt;/Style&gt;
        </pre>
        <li>A mögöttes kód (<strong>MainWindow.xaml.cs</strong>)</li>
        <pre class="brush:csharp">
          //Az EventSetter-el beállított tulajdonság, amivel a MouseDown eseményre iratkoztunk fel
          private void TextBlockMouseDown(object sender, MouseButtonEventArgs e)
          {
            var textBlock = sender as TextBlock;
            if (textBlock != null) 
              MessageBox.Show(textBlock.Text);
          }
        </pre>
        <li>Ezekután már csak annyi a dolgunk hogy használjuk a stílusunkat az <a href="#" class="tooltip" data-tooltip="ebben az esetben a TextBlock-on">adott vezérlon</a>. Ha a felhasználó rákattint a szövegre, akkor felbukkan egy ablak a <strong>Hello World</strong> szöveggel:</li>
        <pre class="brush:xml">
          &lt;!-- Ahogy látható kívülrol szinte nem látszik semmi se: --&gt;
          &lt;TextBlock Style="{StaticResource TextBlockStyle}"&gt;Hello World!&lt;/TextBlock&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="Sablonok a WPF-ben">
      <ul>
        <li>A <strong>WPF</strong>-ben az eddig megismert technológiáktól eltéroen egyszeruen külön tudja választani a vezérlok megjelenítését a funkcionalitástól. Az erre képes vezérloket <strong>lookless control</strong>-oknak nevezzük. </li>
        <li>Miért jó ez nekünk? Egyszeruen azért, mert pusztán stílusok segítségével teljesen testreszabhatjuk a már meglévo vezérloinket úgy, hogy annak a funkcionalitása nem változik meg. Így nincs szükség arra se, hogy új osztályokat hozzunk létre származtatással, vagy alacsony szinten újrarajzoljuk az egészet csak azért, mert egy apró változtatást akartunk végezni rajta. Ezzel a szemlélettel hatalmas szabadságot kap a programozó a kezébe. </li>
        <li>Ha egy vezérlo sablonját szeretnénk megváltoztatni, akkor a <a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.control.template.aspx">Template</a> tulajdonságnak kell egy új <a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.controltemplate.aspx">ControlTemplate</a> objektumot beállítanunk. Ezen belül már bármilyen külcsínt definiálhatunk az adott vezérlonek. </li>
      </ul>
    </div>

    <div class="slide" data-title="Sablonok használata">
      <ul>
        <li>A <strong>ControlTemplate</strong>-nek mindig meg kell adni a <strong>TargetType</strong> tulajdonságán keresztül, hogy milyen típusú vezérlonek szeretnénk megváltoztatni a külsejét.</li>
        <li>Ha a sablonon belül szeretnénk adatkötést használni az adott vezérlo valamelyik tulajdonságára, akkor a <strong>Binding</strong> helyett használhatjuk a <a href="http://msdn.microsoft.com/en-us/library/ms742882(v=vs.110).aspx">TemplateBinding</a> markup extension-t. </li>
        <li>A <a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.contentpresenter.aspx">ContentPresenter</a> vezérlo segítségével lehet egyszeruen megjeleníteni a vezérlo tartalmát (azaz a <strong>Content</strong> tulajdonságon keresztül beállított értéket).</li>
        <pre class="brush:xml">
          &lt;Button Content="OK"&gt;
            &lt;Button.Template&gt; &lt;!-- A Template tulajdonságon keresztül állítjuk be az sablont --&gt;
              &lt;ControlTemplate TargetType="Button"&gt;
                &lt;!-- TemplateBinding segítségével érhetjük el a gombnak beállított háttérszínét --&gt;
                &lt;Border CornerRadius="30"
                        Background="{TemplateBinding Background}"&gt;
                  &lt;!-- Binding-al is meg lehet tenni, de akkor a relatív elérést kell használnunk --&gt;
                  &lt;Label VerticalAlignment="Center"
                         HorizontalAlignment="Center"
                         Foreground="{TemplateBinding Foreground}"
                         FontSize="25"
                         Content="{Binding Content, RelativeSource={RelativeSource TemplatedParent}}"/&gt;
                &lt;/Border&gt;
              &lt;/ControlTemplate&gt;
            &lt;/Button.Template&gt;
          &lt;/Button&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="ItemsControl vezérlo (1/3)">
      <ul>
        <li>A különbözo panelekkel sokmindent meg tudunk jeleníteni, de a legnagyobb probléma velük, hogy nem dinamikus elemek kezelésére lettek kitalálva (ettol függetlenül persze lehet azokra is használni). De erre van egy egyszerubb és elegánsabb megoldás: ez pedig nem más, mint maga az <a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.itemscontrol.aspx">ItemsControl</a> vezérlo (illetve a <a href="http://msdn.microsoft.com/en-us/library/system.windows.controls.listbox.aspx">ListBox</a> vezérlo, ami annyival tud többet, hogy a felsorolt elemeket ki is tudja választani a felhasználó). </li>
        <li>Egyik legfontosabb tulajdonsága az <strong>ItemsSource</strong>, amin keresztül adhatjuk meg a vezérlonek, hogy mely elemeket kell neki megjelenítenie. Tipikusan itt fogjuk összekötni a vezérlot a nézetmodell megfelelo kollekciójával. </li>
        <pre class="brush:xml">
          &lt;Grid xmlns:system="clr-namespace:System;assembly=mscorlib"&gt;
            &lt;Grid.Resources&gt;
              &lt;!-- XAML-ben így készítünk tömböt: -->
              &lt;x:Array Type="system:String" x:Key="DataArray"&gt;
                &lt;system:String&gt;Nick Fury&lt;/system:String&gt;
                &lt;system:String&gt;Bruce Banner&lt;/system:String&gt;
                &lt;system:String&gt;Peter Parker&lt;/system:String&gt;
                &lt;system:String&gt;James "Logan" Howlett&lt;/system:String&gt;
              &lt;/x:Array&gt;
            &lt;/Grid.Resources&gt;
            &lt;ItemsControl ItemsSource="{StaticResource DataArray}" /&gt;
          &lt;/Grid&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="ItemsControl vezérlo (2/3)">
      <ul>
        <li>Az <strong>ItemTemplate</strong>-en kereszül lehet beállítani, hogy maguk az elemek hogyan jelenjenek meg a vezérloben. Itt teljesen szabadjára engedhetjük a fantáziánkat és szinte bármit megalkothatunk, amire nekünk szükségünk van.</li>
        <a href="img/itemtemplate.png" class="image-link"><img src="img/itemtemplate.png" style="margin-left: 25%; width: 50%"></a>
        <pre class="brush:xml">
          &lt;ItemsControl ItemsSource="{StaticResource DataArray}"&gt;
            &lt;ItemsControl.ItemTemplate&gt;
              &lt;DataTemplate&gt;
                &lt;Button Content="{Binding}" /&gt;
              &lt;/DataTemplate&gt;
            &lt;/ItemsControl.ItemTemplate&gt;
          &lt;/ItemsControl&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="ItemsControl vezérlo (3/3)">
      <ul>
        <li>Nemcsak az elemek kirajzolását lehet beállítani, hanem magát azt is, hogy azok hogyan rendezodjenek a vezérlon belül. Ezt pedig az <strong>ItemsPanel</strong> segítségével lehet beállítani. Már ezzel a két tulajdonsággal egy nagyon eros technikai megoldás kerülhet a kezeink közé.</li>
        <a href="img/itemspanel.png" class="image-link"><img src="img/itemspanel.png" style="margin-left: 33%; width: 33%"></a>
        <pre class="brush:xml">
          &lt;ItemsControl ItemsSource="{StaticResource DataArray}"&gt;
            &lt;!-- Itt állítjuk be az elemek elrendezését a vezérlon belül ... --&gt;
            &lt;ItemsControl.ItemsPanel&gt;
              &lt;ItemsPanelTemplate&gt;
                &lt;UniformGrid Rows="2" Columns="2" /&gt;
              &lt;/ItemsPanelTemplate&gt;
            &lt;/ItemsControl.ItemsPanel&gt;
            &lt;ItemsControl.ItemTemplate&gt;
              &lt;DataTemplate&gt;
                &lt;Button Content="{Binding}" /&gt;
              &lt;/DataTemplate&gt;
            &lt;/ItemsControl.ItemTemplate&gt;
          &lt;/ItemsControl&gt;
        </pre>
      </ul>
    </div>

    <div class="slide" data-title="Ajánlott szakirodalom">
      <ul>
        <li>Aki jobban belemélyülne a témába, akkor ezekbol a könyvekbol érdemes szemezgetni: </li>
        <li><strong>Pro WPF 4.5 in C# Windows Presentation Foundation in .NET 4.5</strong> (Matthew MacDonald) - Apress (<a href="http://www.apress.com/microsoft/wpf/9781430243656">link</a>)</li>
        <li><strong>WPF 4.5 Unleashed</strong> (Adam Nathan) - Sams Publishing (<a href="http://www.amazon.com/WPF-4-5-Unleashed-Adam-Nathan/dp/0672336979/ref=sr_1_1?ie=UTF8&qid=1383686687&sr=8-1&keywords=wpf">link</a>)</li>
        <li><strong>Windows Presentation Foundation 4.5 Cookbook</strong> (Pavel Yosifovich) - Packt Publishing (<a href="http://www.amazon.com/Windows-Presentation-Foundation-4-5-Cookbook/dp/184968622X/ref=sr_1_4?ie=UTF8&qid=1383686687&sr=8-4&keywords=wpf">link</a>)</li>
        <li><strong>WPF Control Development Unleashed: Building Advanced User Experiences</strong> (Pavan Podila, Kevin Scott Hoffman) - (<a href="http://www.amazon.com/WPF-Control-Development-Unleashed-Experiences/dp/0672330334/ref=sr_1_13?ie=UTF8&qid=1383686687&sr=8-13&keywords=wpf">link</a>)</li>
      </ul>
    </div>

    <div class="slide" data-template="main">
      <div class="centered">
        <h1>[ Köszönöm a figyelmet! ]</h1>
      </div>
    </div>

  </div>

  <div class="user-interface" id="info">
    <a href="http://sztrabi.web.elte.hu">Szabó Tamás</a> (<a href="mailto:sztrabi@inf.elte.hu">sztrabi@inf.elte.hu</a>) © <a href="http://people.inf.elte.hu/groberto/elte_eva2/index.html">Eseményvezérelt alkalmazások fejlesztése 2</a>
  </div>

  <div class="user-interface">
    <div id="show-menu">Tartalomjegyzék ></div>
    <ol id="menu-items" />
  </div>
  <script src="js/impress.js"></script>
</body>
</html>